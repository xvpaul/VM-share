<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Added viewport-fit for notches; left user zoom behavior unchanged -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Loading OS…</title>
  <style>
    :root {
      --bg: #0b0e13;
      --panel: #0f141c;
      --panel-2: #0c1017;
      --fg: #e8eaed;
      --muted: #99a2ad;
      --border: #1f2632;
      --accent: #4f46e5; /* indigo-600 */
      --accent-2: #22d3ee; /* cyan-400 */
      --ok: #22c55e;      /* green-500 */
      --warn: #f59e0b;    /* amber-500 */
      --danger: #ef4444;  /* red-500 */
    }
    html, body { height:100%; margin:0; background: radial-gradient(1200px 600px at 10% -10%, rgba(79,70,229,.12), transparent),
                                          radial-gradient(1200px 700px at 110% 10%, rgba(34,211,238,.10), transparent),
                                          var(--bg);
      color:var(--fg); font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    /* Layout */
    body { display:grid; grid-template-rows: auto auto 1fr; min-height: 100svh; overscroll-behavior: none; }
    .bar { height:56px; display:flex; align-items:center; gap:12px; padding:0 16px; background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-bottom:1px solid var(--border); backdrop-filter: blur(6px); position: sticky; top:0; z-index:10; }
    .brand { display:flex; align-items:center; gap:10px; }
    .logo { width:28px; height:28px; border-radius:8px; background: conic-gradient(from 210deg, var(--accent), var(--accent-2)); box-shadow: 0 0 0 1px #ffffff14 inset, 0 4px 20px #00000080; }
    .title { font-weight:700; letter-spacing:.1px; font-size:15px; }
    .subtitle { color:var(--muted); font-weight:500; font-size:12px; }
    .spacer { flex:1; }

    /* Buttons */
    .btn { border:1px solid var(--border); background:linear-gradient(180deg, #151c28, #111722); color:var(--fg);
      border-radius:12px; padding:8px 12px; cursor:pointer; font-size:14px; display:inline-flex; align-items:center; gap:8px; transition:transform .08s ease, border-color .2s ease, background .2s ease; }
    .btn:hover { border-color:#2a3547; background:linear-gradient(180deg, #172033, #111722); }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }
    .btn--ghost { background:transparent; }
    .btn--ok { border-color:#1e7e43; }
    .btn--danger { border-color:#592327; }

    /* Icons */
    .icon { width:16px; height:16px; display:inline-block; }

    /* Status strip */
    .status { font-size:12px; color:var(--muted); padding:8px 16px; display:flex; align-items:center; gap:8px; border-bottom:1px solid var(--border); background: var(--panel-2); }
    .dot { width:8px; height:8px; border-radius:999px; background:#6b7280; box-shadow:0 0 0 2px #00000055; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.err { background: var(--danger); }

    /* Screen area */
    #screen { min-height:0; /* mobile: keep gestures for noVNC, not page */ touch-action: none; }
    #screen > canvas { width:100%; height:calc(100svh - 56px - 34px); display:block; image-rendering: crisp-edges; background:#000; }
    /* Prefer dynamic viewport height when supported (better with mobile keyboards) */
    @supports (height: 100dvh) {
      #screen > canvas { height: calc(100dvh - 56px - 34px); }
    }

    /* Toast */
    .toast { position:fixed; right:16px; bottom:16px; background:#0b121b; border:1px solid var(--border); padding:12px 14px; border-radius:12px; box-shadow:0 8px 30px #0008; display:flex; align-items:center; gap:10px; font-size:13px; }
    .toast .dot { box-shadow:none; }

    /* --- Hidden mobile keyboard input (added) --- */
    #vkbd {
      position: fixed;
      /* keep it offscreen & invisible but focusable */
      top: -200px;
      left: 0;
      width: 1px;
      height: 1px;
      opacity: 0;
      border: 0;
      padding: 0;
      background: transparent;
      color: transparent;
      caret-color: transparent;
      z-index: 1; /* under the toolbar */
    }
  </style>
</head>
<body>
  <div class="bar">
    <div class="brand" title="noVNC">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <div class="title"><span id="vm-name">Loading…</span></div>
        <div class="subtitle" id="vm-sub">Remote console</div>
      </div>
    </div>
    <div class="spacer"></div>
    <button id="btn-full" class="btn" title="Fullscreen (F)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 8V4h4M16 4h4v4M4 16v4h4M20 16v4h-4"/></svg>
      Fullscreen
    </button>
    <button id="btn-shot" class="btn btn--ok" title="Snapshot VM (/snapshot)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7h4l2-2h4l2 2h4v12H4z"/><circle cx="12" cy="13" r="3"/></svg>
      Snapshot
    </button>
    <button id="btn-disc" class="btn btn--danger" title="Disconnect (/disconnect)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h13"/><path d="M17 8l4 4-4 4"/></svg>
      Disconnect
    </button>
  </div>

  <div class="status" id="status">
    <span class="dot" id="dot"></span>
    <span id="status-text">Connecting…</span>
  </div>

  <!-- Hidden, focusable input to summon the mobile keyboard (added) -->
  <input id="vkbd" inputmode="text" autocapitalize="off" autocomplete="off" spellcheck="false" aria-hidden="true" />

  <div id="screen"></div>

  <div id="toast" class="toast" style="display:none">
    <span class="dot ok"></span>
    <span id="toast-text">Done</span>
  </div>

  <!-- noVNC core library you copied -->
  <script type="module">
  import RFB from './core/rfb.js';

  const ready = (fn) => {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', fn, { once: true });
    } else {
      fn();
    }
  };

  ready(() => {
    // ——— Cache elements ———
    const dotEl        = document.querySelector('#dot');
    const statusTextEl = document.querySelector('#status-text');
    const vmNameEl     = document.querySelector('#vm-name');
    const vmSubEl      = document.querySelector('#vm-sub');
    const toastEl      = document.querySelector('#toast');
    const toastTextEl  = document.querySelector('#toast-text');
    const btnFull      = document.querySelector('#btn-full');
    const btnDisc      = document.querySelector('#btn-disc');
    const btnShot      = document.querySelector('#btn-shot');
    const screen       = document.getElementById('screen');
    const vkbd         = document.getElementById('vkbd'); // (added)

    if (!screen) {
      console.error('[ui] #screen not found; aborting noVNC init');
      return;
    }

    // ——— UI helpers ———
    function setStatus(text, level = 'info') {
      if (statusTextEl) statusTextEl.textContent = text;
      if (!dotEl) return;
      dotEl.classList.remove('ok', 'warn', 'err');
      if (level === 'ok') dotEl.classList.add('ok');
      else if (level === 'warn') dotEl.classList.add('warn');
      else if (level === 'err') dotEl.classList.add('err');
    }

    let toastTimer;
    function toast(text, level = 'ok') {
      if (!toastEl || !toastTextEl) return;
      toastTextEl.textContent = text;
      const dot = toastEl.querySelector('.dot');
      if (dot) dot.className = 'dot ' + (level === 'ok' ? 'ok' : level === 'err' ? 'err' : 'warn');
      toastEl.style.display = 'flex';
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toastEl.style.display = 'none'; }, 2600);
    }

    // ——— Dynamic title/OS from /user_info ———
    let currentOsType = null;

    async function loadOS() {
      try {
        const res = await fetch('/auth/user_info', { credentials: 'same-origin' });
        const ct = res.headers.get('content-type') || '';
        let os = '';
        if (ct.includes('application/json')) {
          const j = await res.json();
          os = j.os_type;
        } else {
          os = (await res.text()).trim();
        }
        if (!os) os = 'Virtual Machine';
        currentOsType = os;
        document.title = os + ' — Console';
        if (vmNameEl) vmNameEl.textContent = os;
        if (vmSubEl)  vmSubEl.textContent  = 'Remote console via noVNC';
      } catch {
        document.title = 'Console';
        if (vmNameEl) vmNameEl.textContent = 'Console';
        if (vmSubEl)  vmSubEl.textContent  = 'Remote console via noVNC';
      }
    }

    // ——— Build websocket URL ———
    const urlParams = new URLSearchParams(window.location.search);
    const host  = urlParams.get('host') || window.location.hostname || 'localhost';
    const port  = urlParams.get('port') || window.location.port || (location.protocol === 'https:' ? '443' : '80');
    const path  = urlParams.get('path') || 'websockify';
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${proto}://${host}:${port}/${path}`;

    // ——— Setup RFB ———
    const rfb = new RFB(screen, wsUrl, { credentials: {} });
    rfb.viewOnly = false;
    rfb.scaleViewport = true;
    rfb.resizeSession = true;

    rfb.addEventListener('connect',   () => setStatus('Connected', 'ok'));
    rfb.addEventListener('disconnect', (e) => {
      const clean = !e || !e.detail || e.detail.clean;
      setStatus(clean ? 'Disconnected' : 'Disconnected (error)', clean ? 'warn' : 'err');
    });

    // ——— Controls ———
    if (btnFull) {
      btnFull.addEventListener('click', async () => {
        const el = document.documentElement;
        try {
          if (!document.fullscreenElement) await el.requestFullscreen();
          else await document.exitFullscreen();
        } catch {}
      });
    }

    if (btnDisc) {
      btnDisc.addEventListener('click', async () => {
        setStatus('Disconnecting…', 'warn');
        btnDisc.disabled = true;
        try {
          // Prefer POST; fall back to GET if server doesn’t accept it
          let res = await fetch('/disconnect', { method: 'POST', credentials: 'same-origin' });
          if (!res.ok) res = await fetch('/disconnect', { credentials: 'same-origin' });
        } catch {}
        try { rfb.disconnect(); } catch {}
        toast('Disconnected', 'warn');
        btnDisc.disabled = false;
      });
    }

    if (btnShot) {
      btnShot.addEventListener('click', async () => {
        btnShot.disabled = true;
        btnShot.textContent = 'Snapshotting…';
        try {
          const osType = currentOsType || 'unknown';
          const res = await fetch('/vm/snapshot', {
            method: 'POST',
            credentials: 'same-origin',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ os_type: osType })
          });

          let msg = res.ok ? 'Snapshot created' : 'Snapshot failed';
          try {
            const ct = res.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
              const data = await res.json();
              const id = data.id || data.name || data.snapshot || '';
              if (id) msg = `Snapshot ${id} created`;
            } else {
              const t = (await res.text()).trim();
              if (t) msg = t;
            }
          } catch {}

          toast(msg, res.ok ? 'ok' : 'err');
          setStatus('Connected', res.ok ? 'ok' : 'err');
        } catch (e) {
          console.error('[snapshot] fetch failed:', e);
          toast('Snapshot request failed', 'err');
          setStatus('Connected', 'err');
        } finally {
          btnShot.disabled = false;
          btnShot.innerHTML = `
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 7h4l2-2h4l2 2h4v12H4z"/>
              <circle cx="12" cy="13" r="3"/>
            </svg> Snapshot
          `;
        }
      });
    } else {
      console.error('[ui] #btn-shot not found; snapshot disabled');
    }

    // ——— Hotkeys ———
    document.addEventListener('keydown', (e) => {
      if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        btnFull?.click();
      }
    });

    // ——— Mobile keyboard glue (added) ———
    // Map a Unicode code point to an X11 keysym suitable for RFB
    function unicodeToKeysym(ch) {
      const cp = ch.codePointAt(0);
      // Latin-1 range uses value directly; others set the high bit as per X11 convention
      return (cp <= 0xFF) ? cp : (0x01000000 | cp);
    }
    // Common X11 keysyms
    const KS = {
      BackSpace: 0xFF08,
      Tab:       0xFF09,
      Return:    0xFF0D,
      Escape:    0xFF1B,
      Left:      0xFF51,
      Up:        0xFF52,
      Right:     0xFF53,
      Down:      0xFF54,
      PageUp:    0xFF55,
      PageDown:  0xFF56,
      End:       0xFF57,
      Home:      0xFF50,
      Insert:    0xFF63,
      Delete:    0xFFFF,
    };
    function sendKeysym(ks) {
      try {
        // press + release
        rfb.sendKey(ks, null, true);
        rfb.sendKey(ks, null, false);
      } catch (e) {
        // some builds accept single-call (fallback)
        try { rfb.sendKey(ks); } catch {}
      }
    }
    function sendText(s) {
      for (const ch of s) {
        sendKeysym(unicodeToKeysym(ch));
      }
    }

    // Focus the hidden input on first tap to show the OS keyboard
    function focusVKBD() {
      if (!vkbd) return;
      try { vkbd.focus({ preventScroll: true }); } catch { vkbd.focus(); }
    }

    if (vkbd) {
      // When the user taps the VNC screen, show the keyboard
      ['pointerdown','touchstart','mousedown'].forEach(evt => {
        screen.addEventListener(evt, () => {
          focusVKBD();
        }, { passive: false });
      });

      // Intercept special keys and navigation from the soft keyboard
      vkbd.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowLeft':  sendKeysym(KS.Left); break;
          case 'ArrowRight': sendKeysym(KS.Right); break;
          case 'ArrowUp':    sendKeysym(KS.Up); break;
          case 'ArrowDown':  sendKeysym(KS.Down); break;
          case 'Backspace':  sendKeysym(KS.BackSpace); break;
          case 'Delete':     sendKeysym(KS.Delete); break;
          case 'Enter':      sendKeysym(KS.Return); break;
          case 'Tab':        sendKeysym(KS.Tab); break;
          case 'Escape':     sendKeysym(KS.Escape); break;
          case 'Home':       sendKeysym(KS.Home); break;
          case 'End':        sendKeysym(KS.End); break;
          case 'PageUp':     sendKeysym(KS.PageUp); break;
          case 'PageDown':   sendKeysym(KS.PageDown); break;
          default:
            // let normal text be handled in beforeinput/input
            return;
        }
        e.preventDefault();
      });

      // beforeinput gives us the text being inserted (Android/iOS)
      vkbd.addEventListener('beforeinput', (e) => {
        // Handle text and some editing commands
        const t = e.inputType;
        if (t === 'insertText' && e.data) {
          sendText(e.data);
        } else if (t === 'insertLineBreak') {
          sendKeysym(KS.Return);
        } else if (t === 'deleteContentBackward') {
          sendKeysym(KS.BackSpace);
        } else if (t === 'deleteContentForward') {
          sendKeysym(KS.Delete);
        }
        // Keep input empty and prevent the browser from storing text
        e.preventDefault();
      });

      // Fallback for keyboards that only emit "input"
      vkbd.addEventListener('input', () => {
        if (vkbd.value) {
          sendText(vkbd.value);
          vkbd.value = '';
        }
      });

      // Small hint on first touch devices
      const isTouch = matchMedia('(pointer: coarse)').matches;
      if (isTouch) {
        setTimeout(() => toast('Tip: tap the screen to type', 'ok'), 400);
      }
    }

    // Kick off
    setStatus('Connecting…');
    loadOS();
  });
</script>

</body>
</html>
