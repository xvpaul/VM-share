<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- dynamic viewport for better behavior with soft keyboards + notches -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Loading OS…</title>
  <style>
    :root {
      --bg: #0b0e13;
      --panel: #0f141c;
      --panel-2: #0c1017;
      --fg: #e8eaed;
      --muted: #99a2ad;
      --border: #1f2632;
      --accent: #4f46e5; /* indigo-600 */
      --accent-2: #22d3ee; /* cyan-400 */
      --ok: #22c55e;      /* green-500 */
      --warn: #f59e0b;    /* amber-500 */
      --danger: #ef4444;  /* red-500 */
    }
    html, body {
      height:100%;
      margin:0;
      background: radial-gradient(1200px 600px at 10% -10%, rgba(79,70,229,.12), transparent),
                  radial-gradient(1200px 700px at 110% 10%, rgba(34,211,238,.10), transparent),
                  var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Layout */
    body {
      display:grid;
      grid-template-rows: auto auto 1fr;
      min-height: 100svh;
      overscroll-behavior: none; /* avoid rubber-banding while dragging in VNC */
    }
    .bar {
      height:56px; display:flex; align-items:center; gap:12px; padding:0 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(6px);
      position: sticky; top:0; z-index:10;
    }
    .brand { display:flex; align-items:center; gap:10px; }
    .logo { width:28px; height:28px; border-radius:8px; background: conic-gradient(from 210deg, var(--accent), var(--accent-2)); box-shadow: 0 0 0 1px #ffffff14 inset, 0 4px 20px #00000080; }
    .title { font-weight:700; letter-spacing:.1px; font-size:15px; }
    .subtitle { color:var(--muted); font-weight:500; font-size:12px; }
    .spacer { flex:1; }

    /* Buttons */
    .btn {
      border:1px solid var(--border); background:linear-gradient(180deg, #151c28, #111722); color:var(--fg);
      border-radius:12px; padding:8px 12px; cursor:pointer; font-size:14px; display:inline-flex; align-items:center; gap:8px;
      transition:transform .08s ease, border-color .2s ease, background .2s ease;
    }
    .btn:hover { border-color:#2a3547; background:linear-gradient(180deg, #172033, #111722); }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }
    .btn--ghost { background:transparent; }
    .btn--ok { border-color:#1e7e43; }
    .btn--danger { border-color:#592327; }

    /* Icons */
    .icon { width:16px; height:16px; display:inline-block; }

    /* Status strip */
    .status {
      font-size:12px; color:var(--muted); padding:8px 16px; display:flex; align-items:center; gap:8px;
      border-bottom:1px solid var(--border); background: var(--panel-2);
    }
    .dot { width:8px; height:8px; border-radius:999px; background:#6b7280; box-shadow:0 0 0 2px #00000055; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.err { background: var(--danger); }

    /* Screen area */
    #screen { min-height:0; }
    /* critical for touch: let noVNC get gestures, not the browser */
    #screen, #screen canvas { touch-action: none; }
    #screen > canvas {
      width:100%;
      height:calc(100svh - 56px - 34px);
      display:block;
      image-rendering: crisp-edges;
      background:#000;
    }
    @supports (height: 100dvh) {
      #screen > canvas { height: calc(100dvh - 56px - 34px); }
    }

    /* Toast */
    .toast {
      position:fixed; right:16px; bottom:16px; background:#0b121b; border:1px solid var(--border);
      padding:12px 14px; border-radius:12px; box-shadow:0 8px 30px #0008; display:flex; align-items:center; gap:10px; font-size:13px;
    }
    .toast .dot { box-shadow:none; }

    /* Hidden-but-focusable input that summons mobile soft keyboard
       Keep it in-viewport so iOS/Android will show the keyboard, but
       we'll lock body scroll while it's focused to prevent page jumps. */
    #vkbd{
      position: fixed; bottom: 0; left: 0;
      width: 1px; height: 1px;
      opacity: 0; border: 0; padding: 0;
      background: transparent;
      color: transparent; caret-color: transparent;
      z-index: 1; /* under toolbar */
      font-size: 16px; /* avoid iOS zoom on focus */
    }

    /* body state used when keyboard is up to prevent page reposition */
    .scroll-locked {
      width: 100%;
      position: fixed;  /* freeze the page */
      left: 0; right: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div class="bar">
    <div class="brand" title="noVNC">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <div class="title"><span id="vm-name">Loading…</span></div>
        <div class="subtitle" id="vm-sub">Remote console</div>
      </div>
    </div>
    <div class="spacer"></div>
    <button id="btn-full" class="btn" title="Fullscreen (F)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 8V4h4M16 4h4v4M4 16v4h4M20 16v4h-4"/></svg>
      Fullscreen
    </button>
    <button id="btn-shot" class="btn btn--ok" title="Snapshot VM (/snapshot)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7h4l2-2h4l2 2h4v12H4z"/><circle cx="12" cy="13" r="3"/></svg>
      Snapshot
    </button>
    <button id="btn-disc" class="btn btn--danger" title="Disconnect (/disconnect)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h13"/><path d="M17 8l4 4-4 4"/></svg>
      Disconnect
    </button>
  </div>

  <div class="status" id="status">
    <span class="dot" id="dot"></span>
    <span id="status-text">Connecting…</span>
  </div>

  <!-- Focusable input to summon the mobile keyboard -->
  <input id="vkbd"
    inputmode="text" enterkeyhint="enter"
    autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false"
    aria-hidden="true" />

  <div id="screen"></div>

  <div id="toast" class="toast" style="display:none">
    <span class="dot ok"></span>
    <span id="toast-text">Done</span>
  </div>

  <!-- noVNC core -->
  <script type="module">
    import RFB from './core/rfb.js';

    const ready = (fn) => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn, { once: true });
      } else {
        fn();
      }
    };

    ready(() => {
      // ——— Cache elements ———
      const dotEl        = document.querySelector('#dot');
      const statusTextEl = document.querySelector('#status-text');
      const vmNameEl     = document.querySelector('#vm-name');
      const vmSubEl      = document.querySelector('#vm-sub');
      const toastEl      = document.querySelector('#toast');
      const toastTextEl  = document.querySelector('#toast-text');
      const btnFull      = document.querySelector('#btn-full');
      const btnDisc      = document.querySelector('#btn-disc');
      const btnShot      = document.querySelector('#btn-shot');
      const screen       = document.getElementById('screen');
      const vkbd         = document.getElementById('vkbd');

      if (!screen) {
        console.error('[ui] #screen not found; aborting noVNC init');
        return;
      }

      // ——— UI helpers ———
      function setStatus(text, level = 'info') {
        if (statusTextEl) statusTextEl.textContent = text;
        if (!dotEl) return;
        dotEl.classList.remove('ok', 'warn', 'err');
        if (level === 'ok') dotEl.classList.add('ok');
        else if (level === 'warn') dotEl.classList.add('warn');
        else if (level === 'err') dotEl.classList.add('err');
      }

      let toastTimer;
      function toast(text, level = 'ok') {
        if (!toastEl || !toastTextEl) return;
        toastTextEl.textContent = text;
        const dot = toastEl.querySelector('.dot');
        if (dot) dot.className = 'dot ' + (level === 'ok' ? 'ok' : level === 'err' ? 'err' : 'warn');
        toastEl.style.display = 'flex';
        clearTimeout(toastTimer);
        toastTimer = setTimeout(() => { toastEl.style.display = 'none'; }, 2600);
      }

      // ——— Dynamic title/OS from /user_info ———
      let currentOsType = null;

      async function loadOS() {
        try {
          const res = await fetch('/auth/user_info', { credentials: 'same-origin' });
          const ct = res.headers.get('content-type') || '';
          let os = '';
          if (ct.includes('application/json')) {
            const j = await res.json();
            os = j.os_type;
          } else {
            os = (await res.text()).trim();
          }
          if (!os) os = 'Virtual Machine';
          currentOsType = os;
          document.title = os + ' — Console';
          if (vmNameEl) vmNameEl.textContent = os;
          if (vmSubEl)  vmSubEl.textContent  = 'Remote console via noVNC';
        } catch {
          document.title = 'Console';
          if (vmNameEl) vmNameEl.textContent = 'Console';
          if (vmSubEl)  vmSubEl.textContent  = 'Remote console via noVNC';
        }
      }

      // ——— Build websocket URL ———
      const urlParams = new URLSearchParams(window.location.search);
      const host  = urlParams.get('host') || window.location.hostname || 'localhost';
      const port  = urlParams.get('port') || window.location.port || (location.protocol === 'https:' ? '443' : '80');
      const path  = urlParams.get('path') || 'websockify';
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const wsUrl = `${proto}://${host}:${port}/${path}`;

      // ——— Setup RFB ———
      const rfb = new RFB(screen, wsUrl, { credentials: {} });
      rfb.viewOnly = false;
      rfb.scaleViewport = true;
      rfb.resizeSession = true;
      rfb.showDotCursor = true;   // nice on touch devices
      rfb.focusOnClick = false;   // don't steal focus from our hidden input

      rfb.addEventListener('connect',   () => { setStatus('Connected', 'ok'); setCanvasProps(); });
      rfb.addEventListener('disconnect', (e) => {
        const clean = !e || !e.detail || e.detail.clean;
        setStatus(clean ? 'Disconnected' : 'Disconnected (error)', clean ? 'warn' : 'err');
      });

      function setCanvasProps() {
        const cv = screen.querySelector('canvas');
        if (cv) {
          cv.setAttribute('tabindex', '-1'); // prevent canvas focusing (which can close kb)
          cv.style.touchAction = 'none';
        }
      }
      setCanvasProps();

      // ——— Controls ———
      if (btnFull) {
        btnFull.addEventListener('click', async () => {
          const el = document.documentElement;
          try {
            if (!document.fullscreenElement) await el.requestFullscreen();
            else await document.exitFullscreen();
          } catch {}
        });
      }

      if (btnDisc) {
        btnDisc.addEventListener('click', async () => {
          setStatus('Disconnecting…', 'warn');
          btnDisc.disabled = true;
          try {
            // Prefer POST; fall back to GET if server doesn’t accept it
            let res = await fetch('/disconnect', { method: 'POST', credentials: 'same-origin' });
            if (!res.ok) res = await fetch('/disconnect', { credentials: 'same-origin' });
          } catch {}
          try { rfb.disconnect(); } catch {}
          toast('Disconnected', 'warn');
          btnDisc.disabled = false;
        });
      }

      if (btnShot) {
        btnShot.addEventListener('click', async () => {
          btnShot.disabled = true;
          btnShot.textContent = 'Snapshotting…';
          try {
            const osType = currentOsType || 'unknown';
            const res = await fetch('/vm/snapshot', {
              method: 'POST',
              credentials: 'same-origin',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ os_type: osType })
            });

            let msg = res.ok ? 'Snapshot created' : 'Snapshot failed';
            try {
              const ct = res.headers.get('content-type') || '';
              if (ct.includes('application/json')) {
                const data = await res.json();
                const id = data.id || data.name || data.snapshot || '';
                if (id) msg = `Snapshot ${id} created`;
              } else {
                const t = (await res.text()).trim();
                if (t) msg = t;
              }
            } catch {}

            toast(msg, res.ok ? 'ok' : 'err');
            setStatus('Connected', res.ok ? 'ok' : 'err');
          } catch (e) {
            console.error('[snapshot] fetch failed:', e);
            toast('Snapshot request failed', 'err');
            setStatus('Connected', 'err');
          } finally {
            btnShot.disabled = false;
            btnShot.innerHTML = `
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M4 7h4l2-2h4l2 2h4v12H4z"/>
                <circle cx="12" cy="13" r="3"/>
              </svg> Snapshot
            `;
          }
        });
      } else {
        console.error('[ui] #btn-shot not found; snapshot disabled');
      }

      // ——— Hotkeys (desktop convenience) ———
      document.addEventListener('keydown', (e) => {
        if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          btnFull?.click();
        }
      });

      // ——— Scroll lock to prevent page jump on focus ———
      let scrollY = 0;
      function lockScroll() {
        if (document.body.classList.contains('scroll-locked')) return;
        scrollY = window.scrollY || window.pageYOffset || 0;
        document.body.classList.add('scroll-locked');
        document.body.style.top = `-${scrollY}px`;
      }
      function unlockScroll() {
        if (!document.body.classList.contains('scroll-locked')) return;
        const y = -parseInt(document.body.style.top || '0', 10) || 0;
        document.body.classList.remove('scroll-locked');
        document.body.style.top = '';
        window.scrollTo(0, y);
      }

      // ——— Mobile keyboard bridge ———
      function unicodeToKeysym(ch) {
        const cp = ch.codePointAt(0);
        return (cp <= 0xFF) ? cp : (0x01000000 | cp); // X11 convention for Unicode
      }
      const KS = {
        BackSpace: 0xFF08, Tab: 0xFF09, Return: 0xFF0D, Escape: 0xFF1B,
        Left: 0xFF51, Up: 0xFF52, Right: 0xFF53, Down: 0xFF54,
        PageUp: 0xFF55, PageDown: 0xFF56, End: 0xFF57, Home: 0xFF50,
        Insert: 0xFF63, Delete: 0xFFFF,
      };
      function sendKeysym(ks) {
        try {
          rfb.sendKey(ks, null, true);  // press
          rfb.sendKey(ks, null, false); // release
        } catch (e) {
          console.warn('sendKey failed', e);
        }
      }
      function sendText(s) {
        for (const ch of s) sendKeysym(unicodeToKeysym(ch));
      }

      function focusVKBD() {
        if (!vkbd) return;
        lockScroll(); // prevent page from jumping when keyboard appears
        try { vkbd.focus({ preventScroll: true }); } catch { vkbd.focus(); }
      }

      // Tap anywhere on the remote screen to bring up and keep the keyboard
      ['pointerdown','touchstart','mousedown','pointerup','touchend'].forEach(evt => {
        screen.addEventListener(evt, () => focusVKBD(), { passive: true });
      });

      // Release scroll lock when keyboard input loses focus (keyboard hidden)
      vkbd.addEventListener('blur', unlockScroll);

      // Special keys from soft keyboard
      vkbd.addEventListener('keydown', (e) => {
        const km = {
          'Backspace': KS.BackSpace, 'Delete': KS.Delete, 'Enter': KS.Return, 'Tab': KS.Tab, 'Escape': KS.Escape,
          'ArrowLeft': KS.Left, 'ArrowRight': KS.Right, 'ArrowUp': KS.Up, 'ArrowDown': KS.Down,
          'Home': KS.Home, 'End': KS.End, 'PageUp': KS.PageUp, 'PageDown': KS.PageDown
        };
        const ks = km[e.key];
        if (ks) { e.preventDefault(); sendKeysym(ks); }
      });

      // Text entry (Android/iOS): fires before DOM changes so we can forward & keep input empty
      vkbd.addEventListener('beforeinput', (e) => {
        const t = e.inputType;
        if (t === 'insertText' && e.data) {
          sendText(e.data);
        } else if (t === 'insertLineBreak') {
          sendKeysym(KS.Return);
        } else if (t === 'deleteContentBackward') {
          sendKeysym(KS.BackSpace);
        } else if (t === 'deleteContentForward') {
          sendKeysym(KS.Delete);
        }
        e.preventDefault();
      });

      // Composition (IME) finalization
      vkbd.addEventListener('compositionend', (e) => {
        if (e.data) sendText(e.data);
        vkbd.value = '';
      });

      // Fallback for keyboards that only emit "input"
      vkbd.addEventListener('input', () => {
        if (vkbd.value) {
          sendText(vkbd.value);
          vkbd.value = '';
        }
      });

      // Tiny hint for touch users
      const isTouch = matchMedia('(pointer: coarse)').matches;
      if (isTouch) setTimeout(() => toast('Tip: tap the screen to type', 'ok'), 400);

      // Kick off
      setStatus('Connecting…');
      loadOS();
    });
  </script>
</body>
</html>
