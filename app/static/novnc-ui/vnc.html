<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>noVNC – Mobile Friendly</title>
  <style>
    :root {
      --bg: #0b0f14;
      --fg: #e6edf3;
      --muted: #9aa4ae;
      --accent: #5aa3ff;
      --danger: #ff6262;
      --card: #121820;
      --card2: #0f141b;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }

    /* Layout */
    .bar { position: fixed; inset-inline: 0; top: env(safe-area-inset-top); display: flex; gap: .5rem; align-items: center; padding: .5rem .75rem; background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.0)); z-index: 10; }
    .bar .left, .bar .right { display: flex; gap: .5rem; align-items: center; }
    .spacer { flex: 1 1 auto; }

    .btn { appearance: none; border: 0; border-radius: 14px; padding: .55rem .75rem; background: var(--card); color: var(--fg); font-size: .95rem; display: inline-flex; align-items: center; gap: .4rem; box-shadow: 0 1px 0 rgba(255,255,255,.04) inset, 0 0 0 1px rgba(255,255,255,.06) inset, 0 6px 20px rgba(0,0,0,.25); }
    .btn[aria-pressed="true"] { outline: 2px solid var(--accent); background: var(--card2); }
    .btn.danger { background: #2b1313; color: #ffdcdc; }
    .btn:disabled { opacity: .5; }

    .badge { font-size: .8rem; color: var(--muted); }

    #screen { position: fixed; inset: calc(env(safe-area-inset-top) + 48px) 0 calc(env(safe-area-inset-bottom) + 56px) 0; /* leave room for bars */ }
    #target { position: absolute; inset: 0; touch-action: none; background: #000; }
    canvas { display:block; width:100%; height:100%; }

    /* Bottom action row for mobile */
    .dock { position: fixed; inset-inline: 0; bottom: env(safe-area-inset-bottom); display: grid; grid-auto-flow: column; grid-auto-columns: 1fr; gap: .5rem; padding: .5rem .75rem; background: linear-gradient(0deg, rgba(0,0,0,.4), rgba(0,0,0,0)); z-index: 10; }

    /* Soft keyboard panel */
    #oskPanel { position: fixed; left: 0; right: 0; bottom: 0; transform: translateY(100%); transition: transform .2s ease; background: var(--card); border-top: 1px solid rgba(255,255,255,.08); padding: .5rem .75rem .75rem; z-index: 30; }
    #oskPanel.show { transform: translateY(0); }
    #osk { width: 100%; height: 44px; font-size: 18px; border-radius: 12px; border: 1px solid rgba(255,255,255,.12); background: var(--card2); color: var(--fg); padding: .5rem .75rem; }

    .kbd { display:inline-flex; align-items:center; justify-content:center; min-width:2.2rem; height:2.2rem; border-radius:10px; background:var(--card2); border:1px solid rgba(255,255,255,.1); }
    .kbd-row { display:flex; gap:.4rem; margin-top:.4rem; }

    @media (min-width: 768px) {
      .bar, .dock { padding-inline: 1rem; }
      #osk { height: 36px; }
    }
  </style>
</head>
<body>
  <div class="bar" role="toolbar">
    <div class="left">
      <button id="connectBtn" class="btn">Connect</button>
      <button id="disconnectBtn" class="btn danger" disabled>Disconnect</button>
      <span id="status" class="badge">disconnected</span>
    </div>
    <div class="spacer"></div>
    <div class="right">
      <button id="kbdBtn" class="btn" aria-pressed="false" title="Toggle soft keyboard">Keyboard</button>
      <button id="fsBtn" class="btn" title="Fullscreen">Fullscreen</button>
    </div>
  </div>

  <main id="screen">
    <!-- This is where noVNC will render the remote framebuffer -->
    <div id="target" tabindex="-1" aria-label="VNC screen"></div>
  </main>

  <div class="dock">
    <button id="cadBtn" class="btn" title="Send Ctrl+Alt+Del">Ctrl+Alt+Del</button>
    <button id="escBtn" class="btn" title="Send Escape">Esc</button>
    <button id="altBtn" class="btn" aria-pressed="false" title="Hold Alt">Alt</button>
    <button id="ctrlBtn" class="btn" aria-pressed="false" title="Hold Ctrl">Ctrl</button>
    <button id="rightClickBtn" class="btn" title="Right click">Right‑click</button>
  </div>

  <!-- Soft keyboard panel (uses a real <textarea> to summon the mobile IME) -->
  <section id="oskPanel" aria-hidden="true">
    <textarea id="osk" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" placeholder="Type here…"></textarea>
    <div class="kbd-row">
      <button class="kbd" data-key="\r" title="Enter">⏎</button>
      <button class="kbd" data-key="\b" title="Backspace">⌫</button>
      <button class="kbd" data-key="\t" title="Tab">⇥</button>
      <button class="kbd" data-key="\x1b" title="Escape">Esc</button>
      <button class="kbd" id="arrowLeft" title="Left">←</button>
      <button class="kbd" id="arrowUp" title="Up">↑</button>
      <button class="kbd" id="arrowDown" title="Down">↓</button>
      <button class="kbd" id="arrowRight" title="Right">→</button>
    </div>
  </section>

  <!--
    IMPORTANT: This file assumes you have a local copy of noVNC. If your directory
    looks like the standard noVNC repo, keep the import below. Otherwise, adjust
    the path to rfb.js accordingly (e.g. "./node_modules/@novnc/novnc/core/rfb.js").
  -->
  <script type="module">
    import RFB from './core/rfb.js';

    // --- Helpers -----------------------------------------------------------
    const $ = (sel) => document.querySelector(sel);
    const qs = (key, def = '') => new URLSearchParams(location.search).get(key) ?? def;

    const target = $('#target');
    const statusEl = $('#status');
    const connectBtn = $('#connectBtn');
    const disconnectBtn = $('#disconnectBtn');
    const kbdBtn = $('#kbdBtn');
    const fsBtn = $('#fsBtn');

    const oskPanel = $('#oskPanel');
    const osk = $('#osk');

    const ctrlBtn = $('#ctrlBtn');
    const altBtn = $('#altBtn');

    let rfb;

    // Track modifier state for simple combos
    let ctrlHeld = false;
    let altHeld = false;

    // Build a ws URL from query params, e.g. ?host=localhost&port=6080&path=websockify
    function buildUrl() {
      // If the page is already behind a WebSockify path, allow relative path via wsPath
      let host = qs('host') || location.hostname;
      let port = qs('port') || location.port || (location.protocol === 'https:' ? '443' : '80');
      let path = (qs('path') || 'websockify').replace(/^\/+/, '');
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      return `${proto}://${host}:${port}/${path}`;
    }

    function setStatus(text) { statusEl.textContent = text; }

    function connect() {
      const url = buildUrl();
      const opts = { shared: true, credentials: { username: qs('username') || '', password: qs('password') || '' } };
      rfb = new RFB(target, url, opts);

      // Mobile-friendly viewing
      rfb.viewOnly = false;
      rfb.clipViewport = true;      // prevent huge desktops from overflowing
      rfb.scaleViewport = true;     // scale to fit the phone screen
      rfb.resizeSession = true;     // ask the server to resize to our screen if supported

      rfb.addEventListener('connect', () => { setStatus('connected'); connectBtn.disabled = true; disconnectBtn.disabled = false; });
      rfb.addEventListener('disconnect', (e) => { setStatus('disconnected'); connectBtn.disabled = false; disconnectBtn.disabled = true; if (e.detail?.clean === false) console.warn('VNC disconnect:', e.detail?.reason); });
      rfb.addEventListener('credentialsrequired', () => {
        // If the server requires credentials not supplied in the query, prompt once
        const password = prompt('VNC Password');
        rfb.sendCredentials({ password });
      });

      // Better touch: single-finger = left button drag; two-finger = scroll; tap‑and‑hold = right click
      installTouchGestures();

      setStatus('connecting…');
    }

    function disconnect() {
      if (rfb) {
        rfb.disconnect();
        rfb = null;
        setStatus('disconnected');
      }
    }

    // --- Touch + gestures --------------------------------------------------
    function installTouchGestures() {
      const el = target;
      let longPressTimer = null;
      let rightClickPending = false;

      el.addEventListener('contextmenu', (e) => e.preventDefault());

      el.addEventListener('touchstart', (e) => {
        if (!rfb) return;
        if (e.touches.length === 1) {
          const { x, y } = clientToDisplay(e.touches[0]);
          rfb.sendPointer(x, y, 1); // left down
          longPressTimer = setTimeout(() => {
            // turn into right click hold if user holds ~500ms
            rfb.sendPointer(x, y, 4); // right down
            rightClickPending = true;
          }, 500);
        }
        e.preventDefault();
      }, { passive: false });

      el.addEventListener('touchmove', (e) => {
        if (!rfb) return;
        if (e.touches.length === 1) {
          const { x, y } = clientToDisplay(e.touches[0]);
          const btnMask = rightClickPending ? 4 : 1;
          rfb.sendPointer(x, y, btnMask);
        } else if (e.touches.length === 2) {
          // two-finger scroll
          const dy = e.touches[0].clientY - e.touches[1].clientY; // dummy read to force event
          // Use wheel events via RFB "sendWheel" if available, otherwise emulate via pointer y steps
          if (typeof rfb.sendWheel === 'function') {
            rfb.sendWheel(0, dy > 0 ? 1 : -1);
          }
        }
        e.preventDefault();
      }, { passive: false });

      el.addEventListener('touchend', (e) => {
        if (!rfb) return;
        clearTimeout(longPressTimer); longPressTimer = null;
        const btnMask = rightClickPending ? 0 : 0; // release all
        // Send a release at last known position
        const touch = e.changedTouches[0];
        if (touch) {
          const { x, y } = clientToDisplay(touch);
          rfb.sendPointer(x, y, btnMask);
        } else {
          // safe release at 0,0
          rfb.sendPointer(0, 0, 0);
        }
        rightClickPending = false;
        e.preventDefault();
      }, { passive: false });
    }

    function clientToDisplay(touch) {
      // Map client coordinates to the framebuffer coordinate space.
      // noVNC keeps a canvas sized to CSS, but internally tracks display scale.
      // The RFB object exposes _display for scale/size; we avoid private access by computing ratios.
      const canvas = target.querySelector('canvas');
      const rect = target.getBoundingClientRect();
      const cx = (touch.clientX - rect.left);
      const cy = (touch.clientY - rect.top);
      const fbW = canvas?.width || rect.width;   // fallback if canvas not ready
      const fbH = canvas?.height || rect.height;
      const x = Math.max(0, Math.min(fbW - 1, Math.round(cx * (fbW / rect.width))));
      const y = Math.max(0, Math.min(fbH - 1, Math.round(cy * (fbH / rect.height))));
      return { x, y };
    }

    // --- Soft keyboard / input forwarding ---------------------------------
    function showOSK(show) {
      oskPanel.classList.toggle('show', show);
      oskPanel.setAttribute('aria-hidden', show ? 'false' : 'true');
      kbdBtn.setAttribute('aria-pressed', show ? 'true' : 'false');
      if (show) setTimeout(() => osk.focus(), 50);
      else target.focus();
    }

    // Forward literal text typed into the textarea
    let lastVal = '';
    osk.addEventListener('input', () => {
      const curr = osk.value;
      // Find the appended part or backspaces
      if (curr.length > lastVal.length) {
        const added = curr.slice(lastVal.length);
        for (const ch of added) sendKeyString(ch);
      } else if (curr.length < lastVal.length) {
        const n = lastVal.length - curr.length;
        for (let i = 0; i < n; i++) sendSpecial('backspace');
      }
      lastVal = curr;
    });

    // Also react to special keys from the device keyboard
    osk.addEventListener('keydown', (e) => {
      if (!rfb) return;
      if (e.key === 'Enter') { e.preventDefault(); sendSpecial('enter'); return; }
      if (e.key === 'Backspace') { e.preventDefault(); sendSpecial('backspace'); return; }
      if (e.key === 'Tab') { e.preventDefault(); sendSpecial('tab'); return; }
      if (e.key === 'Escape') { e.preventDefault(); sendSpecial('esc'); return; }
    });

    function sendKeyString(str) {
      if (!rfb) return;
      // Apply held modifiers
      if (ctrlHeld) rfb.sendKey('ControlLeft', 'ControlLeft', true);
      if (altHeld) rfb.sendKey('AltLeft', 'AltLeft', true);
      rfb.sendKey(str);
      if (altHeld) rfb.sendKey('AltLeft', 'AltLeft', false);
      if (ctrlHeld) rfb.sendKey('ControlLeft', 'ControlLeft', false);
    }

    function sendSpecial(name) {
      if (!rfb) return;
      const map = {
        enter: '\\r',
        backspace: '\\b',
        tab: '\\t',
        esc: '\\x1b',
        left: 'ArrowLeft',
        right: 'ArrowRight',
        up: 'ArrowUp',
        down: 'ArrowDown'
      };
      const val = map[name];
      if (!val) return;
      // Arrow keys via code string; others via control characters
      if (val.startsWith('Arrow')) {
        rfb.sendKey(val);
      } else {
        rfb.sendKey(val);
      }
    }

    // --- UI wiring ---------------------------------------------------------
    connectBtn.addEventListener('click', () => connect());
    disconnectBtn.addEventListener('click', () => disconnect());

    $('#cadBtn').addEventListener('click', () => {
      if (!rfb) return;
      rfb.sendKey('ControlLeft', 'ControlLeft', true);
      rfb.sendKey('AltLeft', 'AltLeft', true);
      rfb.sendKey('Delete');
      rfb.sendKey('AltLeft', 'AltLeft', false);
      rfb.sendKey('ControlLeft', 'ControlLeft', false);
    });

    $('#escBtn').addEventListener('click', () => sendSpecial('esc'));

    $('#rightClickBtn').addEventListener('click', () => {
      if (!rfb) return;
      // Send a right click at the center to open context menus if needed
      const rect = target.getBoundingClientRect();
      const fake = { clientX: rect.left + rect.width/2, clientY: rect.top + rect.height/2 };
      const { x, y } = clientToDisplay(fake);
      rfb.sendPointer(x, y, 4); // right down
      setTimeout(() => rfb.sendPointer(x, y, 0), 50);
    });

    kbdBtn.addEventListener('click', () => {
      const show = !oskPanel.classList.contains('show');
      showOSK(show);
    });

    fsBtn.addEventListener('click', async () => {
      const root = document.documentElement;
      if (!document.fullscreenElement) {
        await root.requestFullscreen().catch(()=>{});
      } else {
        await document.exitFullscreen().catch(()=>{});
      }
    });

    ctrlBtn.addEventListener('click', () => {
      ctrlHeld = !ctrlHeld;
      ctrlBtn.setAttribute('aria-pressed', String(ctrlHeld));
    });
    altBtn.addEventListener('click', () => {
      altHeld = !altHeld;
      altBtn.setAttribute('aria-pressed', String(altHeld));
    });

    // Auto-connect when query params are provided (?host=...&port=...)
    if (qs('host') || qs('path') || qs('port')) connect();

    // Prevent iOS from zooming the UI buttons on double-tap
    document.addEventListener('gesturestart', (e)=> e.preventDefault());
  </script>
</body>
</html>
