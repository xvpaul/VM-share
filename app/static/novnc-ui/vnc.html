<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Mobile viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Loading OS…</title>
  <style>
    :root {
      --bg: #0b0e13;
      --panel: #0f141c;
      --panel-2: #0c1017;
      --fg: #e8eaed;
      --muted: #99a2ad;
      --border: #1f2632;
      --accent: #4f46e5;
      --accent-2: #22d3ee;
      --ok: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --bar-h: 56px;
      --status-h: 34px;
      --vh: 100dvh; /* updated dynamically via VisualViewport for mobile keyboards */
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    html, body {
      height:100%;
      margin:0;
      background: radial-gradient(1200px 600px at 10% -10%, rgba(79,70,229,.12), transparent),
                  radial-gradient(1200px 700px at 110% 10%, rgba(34,211,238,.10), transparent),
                  var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overscroll-behavior: contain; /* prevent pull-to-refresh while interacting */
      -webkit-tap-highlight-color: transparent;
    }
    /* Layout */
    body { display:grid; grid-template-rows: auto auto 1fr; min-height: var(--vh); }

    .bar {
      height:var(--bar-h);
      display:flex; align-items:center; gap:12px; padding:0 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-bottom:1px solid var(--border); backdrop-filter: blur(6px);
      position: sticky; top:0; z-index:10;
    }
    .brand { display:flex; align-items:center; gap:10px; min-width:0; }
    .logo { width:28px; height:28px; border-radius:8px; background: conic-gradient(from 210deg, var(--accent), var(--accent-2)); box-shadow: 0 0 0 1px #ffffff14 inset, 0 4px 20px #00000080; }
    .title { font-weight:700; letter-spacing:.1px; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .subtitle { color:var(--muted); font-weight:500; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .spacer { flex:1; }

    /* Buttons */
    .btn {
      border:1px solid var(--border); background:linear-gradient(180deg, #151c28, #111722); color:var(--fg);
      border-radius:12px; padding:10px 14px; cursor:pointer; font-size:14px;
      display:inline-flex; align-items:center; gap:8px; transition:transform .08s ease, border-color .2s ease, background .2s ease;
      touch-action: manipulation;
    }
    .btn:hover { border-color:#2a3547; background:linear-gradient(180deg, #172033, #111722); }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity:.6; cursor:not-allowed; }
    .btn--ghost { background:transparent; }
    .btn--ok { border-color:#1e7e43; }
    .btn--danger { border-color:#592327; }

    /* Icons */
    .icon { width:16px; height:16px; display:inline-block; }

    /* Status strip */
    .status { font-size:12px; color:var(--muted); padding:8px 16px; display:flex; align-items:center; gap:8px; border-bottom:1px solid var(--border); background: var(--panel-2); }
    .dot { width:8px; height:8px; border-radius:999px; background:#6b7280; box-shadow:0 0 0 2px #00000055; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--warn); }
    .dot.err { background: var(--danger); }

    /* Screen area */
    #screen { min-height:0; position:relative; }
    #screen > canvas {
      width:100%;
      height:calc(var(--vh) - var(--bar-h) - var(--status-h));
      display:block; background:#000;
      image-rendering: crisp-edges;
      touch-action: none;           /* important: let noVNC handle gestures */
      -ms-touch-action: none;
    }

    /* Toast */
    .toast { position:fixed; right:16px; bottom:calc(16px + var(--safe-bottom)); background:#0b121b; border:1px solid var(--border); padding:12px 14px; border-radius:12px; box-shadow:0 8px 30px #0008; display:flex; align-items:center; gap:10px; font-size:13px; z-index:20; }
    .toast .dot { box-shadow:none; }

    /* --- MOBILE KEYBOARD STRIP --- */
    .ime {
      position:fixed; left:0; right:0;
      bottom:0;
      padding:8px 10px calc(8px + var(--safe-bottom));
      background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-top:1px solid var(--border);
      display:none; gap:8px; align-items:center; z-index:15;
      backdrop-filter: blur(6px);
    }
    .ime.show { display:flex; }
    .ime textarea {
      flex:1; min-height:40px; max-height:120px; resize:none; border:1px solid var(--border);
      border-radius:10px; background:#0b121b; color:var(--fg); padding:10px 12px;
      font: 16px ui-sans-serif, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      /* Prevent mobile autocorrect weirdness */
      autocapitalize:none; -webkit-user-select:text;
    }
    .kbd-keys { display:flex; gap:6px; flex-wrap:wrap; }
    .kbd {
      border:1px solid var(--border); background:#0f141c; border-radius:10px; padding:8px 10px; font-size:13px;
      min-width:44px; min-height:36px; display:inline-flex; align-items:center; justify-content:center; user-select:none;
    }
    .kbd.toggle.on { border-color:#3b82f6; box-shadow:0 0 0 1px #3b82f6 inset; }
    @media (max-width: 480px) {
      .title { max-width: 38vw; }
      .subtitle { display:none; }
    }
  </style>
</head>
<body>
  <div class="bar">
    <div class="brand" title="noVNC">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <div class="title"><span id="vm-name">Loading…</span></div>
        <div class="subtitle" id="vm-sub">Remote console</div>
      </div>
    </div>
    <div class="spacer"></div>

    <!-- New: Keyboard toggle for mobile -->
    <button id="btn-kbd" class="btn" title="Show Keyboard (mobile)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="5" width="18" height="14" rx="2"/><path d="M7 10h.01M11 10h.01M15 10h.01M7 14h10"/></svg>
      Keyboard
    </button>

    <button id="btn-full" class="btn" title="Fullscreen (F)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 8V4h4M16 4h4v4M4 16v4h4M20 16v4h-4"/></svg>
      Fullscreen
    </button>
    <button id="btn-shot" class="btn btn--ok" title="Snapshot VM (/snapshot)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7h4l2-2h4l2 2h4v12H4z"/><circle cx="12" cy="13" r="3"/></svg>
      Snapshot
    </button>
    <button id="btn-disc" class="btn btn--danger" title="Disconnect (/disconnect)">
      <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h13"/><path d="M17 8l4 4-4 4"/></svg>
      Disconnect
    </button>
  </div>

  <div class="status" id="status">
    <span class="dot" id="dot"></span>
    <span id="status-text">Connecting…</span>
  </div>

  <div id="screen"></div>

  <!-- Mobile IME/keys strip -->
  <div id="ime" class="ime" aria-label="Mobile keyboard strip">
    <textarea id="ime-input"
      placeholder="Type here…"
      autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"
      enterkeyhint="enter"></textarea>
    <div class="kbd-keys">
      <button class="kbd" data-key="Esc">Esc</button>
      <button class="kbd" data-key="Tab">Tab</button>
      <button class="kbd" data-key="Backspace">⌫</button>
      <button class="kbd" data-key="Enter">⏎</button>
      <button class="kbd" data-key="Left">←</button>
      <button class="kbd" data-key="Up">↑</button>
      <button class="kbd" data-key="Down">↓</button>
      <button class="kbd" data-key="Right">→</button>
      <button class="kbd toggle" id="mod-ctrl">Ctrl</button>
      <button class="kbd toggle" id="mod-alt">Alt</button>
      <button class="kbd toggle" id="mod-shift">Shift</button>
      <button class="kbd" id="cad">Ctrl+Alt+Del</button>
    </div>
  </div>

  <div id="toast" class="toast" style="display:none">
    <span class="dot ok"></span>
    <span id="toast-text">Done</span>
  </div>

  <!-- noVNC core library you copied -->
  <script type="module">
  import RFB from './core/rfb.js';

  // Run after DOM is ready
  const ready = (fn) => {
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn, { once: true });
    else fn();
  };

  ready(() => {
    // ——— Cache elements ———
    const dotEl        = document.querySelector('#dot');
    const statusTextEl = document.querySelector('#status-text');
    const vmNameEl     = document.querySelector('#vm-name');
    const vmSubEl      = document.querySelector('#vm-sub');
    const toastEl      = document.querySelector('#toast');
    const toastTextEl  = document.querySelector('#toast-text');
    const btnFull      = document.querySelector('#btn-full');
    const btnDisc      = document.querySelector('#btn-disc');
    const btnShot      = document.querySelector('#btn-shot');
    const btnKbd       = document.querySelector('#btn-kbd');
    const screen       = document.getElementById('screen');
    const ime          = document.getElementById('ime');
    const imeInput     = document.getElementById('ime-input');
    const modCtrlBtn   = document.getElementById('mod-ctrl');
    const modAltBtn    = document.getElementById('mod-alt');
    const modShiftBtn  = document.getElementById('mod-shift');
    const cadBtn       = document.getElementById('cad');

    if (!screen) {
      console.error('[ui] #screen not found; aborting noVNC init');
      return;
    }

    // --- VisualViewport -> CSS var for correct height when keyboard shows ---
    function setVH() {
      const vv = window.visualViewport;
      const vh = vv ? vv.height : window.innerHeight;
      document.documentElement.style.setProperty('--vh', vh + 'px');
    }
    setVH();
    window.addEventListener('resize', setVH);
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', setVH);
      visualViewport.addEventListener('scroll', setVH);
    }

    // ——— UI helpers ———
    function setStatus(text, level = 'info') {
      if (statusTextEl) statusTextEl.textContent = text;
      if (!dotEl) return;
      dotEl.classList.remove('ok', 'warn', 'err');
      if (level === 'ok') dotEl.classList.add('ok');
      else if (level === 'warn') dotEl.classList.add('warn');
      else if (level === 'err') dotEl.classList.add('err');
    }

    let toastTimer;
    function toast(text, level = 'ok') {
      if (!toastEl || !toastTextEl) return;
      toastTextEl.textContent = text;
      const dot = toastEl.querySelector('.dot');
      if (dot) dot.className = 'dot ' + (level === 'ok' ? 'ok' : level === 'err' ? 'err' : 'warn');
      toastEl.style.display = 'flex';
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { toastEl.style.display = 'none'; }, 2600);
    }

    // ——— Dynamic title/OS from /user_info ———
    let currentOsType = null;

    async function loadOS() {
      try {
        const res = await fetch('/auth/user_info', { credentials: 'same-origin' });
        const ct = res.headers.get('content-type') || '';
        let os = '';
        if (ct.includes('application/json')) {
          const j = await res.json();
          os = j.os_type;
        } else {
          os = (await res.text()).trim();
        }
        if (!os) os = 'Virtual Machine';
        currentOsType = os;
        document.title = os + ' — Console';
        if (vmNameEl) vmNameEl.textContent = os;
        if (vmSubEl)  vmSubEl.textContent  = 'Remote console via noVNC';
      } catch {
        document.title = 'Console';
        if (vmNameEl) vmNameEl.textContent = 'Console';
        if (vmSubEl)  vmSubEl.textContent  = 'Remote console via noVNC';
      }
    }

    // ——— Build websocket URL ———
    const urlParams = new URLSearchParams(window.location.search);
    const host  = urlParams.get('host') || window.location.hostname || 'localhost';
    const port  = urlParams.get('port') || window.location.port || (location.protocol === 'https:' ? '443' : '80');
    const path  = urlParams.get('path') || 'websockify';
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${proto}://${host}:${port}/${path}`;

    // ——— Setup RFB ———
    const rfb = new RFB(screen, wsUrl, { credentials: {} });

    // Mobile-friendly defaults
    rfb.viewOnly = false;
    rfb.scaleViewport = true;   // scale to fit
    rfb.clipViewport  = true;   // keep within view when zoomed
    rfb.dragViewport  = true;   // two-finger drag to pan
    // On mobile, avoid constantly resizing the remote desktop
    rfb.resizeSession = !/Mobi|Android|iPad|iPhone|iPod/i.test(navigator.userAgent) ;

    rfb.addEventListener('connect',   () => setStatus('Connected', 'ok'));
    rfb.addEventListener('disconnect', (e) => {
      const clean = !e || !e.detail || e.detail.clean;
      setStatus(clean ? 'Disconnected' : 'Disconnected (error)', clean ? 'warn' : 'err');
    });

    // ——— Controls ———
    if (btnFull) {
      btnFull.addEventListener('click', async () => {
        const el = document.documentElement;
        try {
          if (!document.fullscreenElement) await el.requestFullscreen();
          else await document.exitFullscreen();
        } catch {}
      }, { passive: true });
    }

    if (btnDisc) {
      btnDisc.addEventListener('click', async () => {
        setStatus('Disconnecting…', 'warn');
        btnDisc.disabled = true;
        try {
          let res = await fetch('/disconnect', { method: 'POST', credentials: 'same-origin' });
          if (!res.ok) res = await fetch('/disconnect', { credentials: 'same-origin' });
        } catch {}
        try { rfb.disconnect(); } catch {}
        toast('Disconnected', 'warn');
        btnDisc.disabled = false;
      });
    }

    if (btnShot) {
      btnShot.addEventListener('click', async () => {
        btnShot.disabled = true;
        btnShot.textContent = 'Snapshotting…';
        try {
          const osType = currentOsType || 'unknown';
          const res = await fetch('/vm/snapshot', {
            method: 'POST',
            credentials: 'same-origin',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ os_type: osType })
          });

          let msg = res.ok ? 'Snapshot created' : 'Snapshot failed';
          try {
            const ct = res.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
              const data = await res.json();
              const id = data.id || data.name || data.snapshot || '';
              if (id) msg = `Snapshot ${id} created`;
            } else {
              const t = (await res.text()).trim();
              if (t) msg = t;
            }
          } catch {}

          toast(msg, res.ok ? 'ok' : 'err');
          setStatus('Connected', res.ok ? 'ok' : 'err');
        } catch (e) {
          console.error('[snapshot] fetch failed:', e);
          toast('Snapshot request failed', 'err');
          setStatus('Connected', 'err');
        } finally {
          btnShot.disabled = false;
          btnShot.innerHTML = `
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 7h4l2-2h4l2 2h4v12H4z"/>
              <circle cx="12" cy="13" r="3"/>
            </svg> Snapshot
          `;
        }
      });
    }

    // ——— Hotkeys ———
    document.addEventListener('keydown', (e) => {
      if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        btnFull?.click();
      }
    });

    // ——— MOBILE: IME & on-screen keys ———
    const KS = { // X11 keysyms used by VNC
      Backspace: 0xFF08, Tab: 0xFF09, Enter: 0xFF0D, Escape: 0xFF1B,
      Shift_L: 0xFFE1, Control_L: 0xFFE3, Alt_L: 0xFFE9, Super_L: 0xFFEB,
      Left: 0xFF51, Up: 0xFF52, Right: 0xFF53, Down: 0xFF54,
      Delete: 0xFFFF
    };

    function sendKeysym(ksym, down = true) {
      try { rfb.sendKey(ksym, undefined, down); } catch (e) { console.warn('sendKey failed', e); }
    }
    function sendText(str) {
      for (const ch of str) {
        // For basic Latin, keysym == Unicode code point
        sendKeysym(ch.codePointAt(0), true);
        sendKeysym(ch.codePointAt(0), false);
      }
    }

    // Sticky modifiers
    const mods = { ctrl:false, alt:false, shift:false };
    function applyModifiersDown() {
      if (mods.ctrl)  sendKeysym(KS.Control_L, true);
      if (mods.alt)   sendKeysym(KS.Alt_L, true);
      if (mods.shift) sendKeysym(KS.Shift_L, true);
    }
    function releaseModifiers() {
      if (mods.shift) sendKeysym(KS.Shift_L, false);
      if (mods.alt)   sendKeysym(KS.Alt_L, false);
      if (mods.ctrl)  sendKeysym(KS.Control_L, false);
    }
    function pulseWithMods(fn) {
      applyModifiersDown();
      fn();
      releaseModifiers();
    }

    function toggleBtn(btn, key) {
      mods[key] = !mods[key];
      btn.classList.toggle('on', mods[key]);
      if (mods[key]) {
        // Press down immediately so next key affects remote instantly
        if (key === 'ctrl')  sendKeysym(KS.Control_L, true);
        if (key === 'alt')   sendKeysym(KS.Alt_L, true);
        if (key === 'shift') sendKeysym(KS.Shift_L, true);
      } else {
        if (key === 'ctrl')  sendKeysym(KS.Control_L, false);
        if (key === 'alt')   sendKeysym(KS.Alt_L, false);
        if (key === 'shift') sendKeysym(KS.Shift_L, false);
      }
    }

    // Show/hide IME strip
    btnKbd?.addEventListener('click', () => {
      const showing = ime.classList.toggle('show');
      if (showing) {
        imeInput.focus();
        // Ensure the canvas height updates once keyboard slides in
        setTimeout(setVH, 250);
      } else {
        imeInput.blur();
        setTimeout(setVH, 100);
      }
    });

    // Prevent the page from scrolling while user pans/zooms the remote desktop
    screen.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });

    // On-screen fixed keys
    document.querySelectorAll('.kbd-keys .kbd[data-key]').forEach(btn => {
      btn.addEventListener('click', () => {
        const k = btn.getAttribute('data-key');
        const simple = {
          'Esc': KS.Escape, 'Tab': KS.Tab, 'Backspace': KS.Backspace, 'Enter': KS.Enter,
          'Left': KS.Left, 'Up': KS.Up, 'Right': KS.Right, 'Down': KS.Down, 'Delete': KS.Delete
        }[k];
        if (simple) {
          pulseWithMods(() => { sendKeysym(simple, true); sendKeysym(simple, false); });
        }
      });
    });

    modCtrlBtn?.addEventListener('click', () => toggleBtn(modCtrlBtn, 'ctrl'));
    modAltBtn?.addEventListener('click', () => toggleBtn(modAltBtn, 'alt'));
    modShiftBtn?.addEventListener('click', () => toggleBtn(modShiftBtn, 'shift'));

    cadBtn?.addEventListener('click', () => {
      try { rfb.sendCtrlAltDel(); } catch {}
    });

    // IME text -> VM (works with iOS/Android)
    // We use beforeinput to capture operations like delete/enter reliably.
    imeInput?.addEventListener('beforeinput', (e) => {
      const type = e.inputType;
      const data = e.data || '';
      // Don’t actually keep text in the textarea (it’s a sink)
      e.preventDefault();

      if (type === 'insertText' && data) {
        pulseWithMods(() => sendText(data));
        return;
      }
      if (type === 'insertLineBreak' || type === 'insertParagraph') {
        pulseWithMods(() => { sendKeysym(KS.Enter, true); sendKeysym(KS.Enter, false); });
        return;
      }
      if (type === 'deleteContentBackward') {
        pulseWithMods(() => { sendKeysym(KS.Backspace, true); sendKeysym(KS.Backspace, false); });
        return;
      }
      if (type === 'deleteContentForward') {
        pulseWithMods(() => { sendKeysym(KS.Delete, true); sendKeysym(KS.Delete, false); });
        return;
      }
      // Fallback: on some keyboards, we may get plain input
      if (data) pulseWithMods(() => sendText(data));
    });

    // Some IMEs send committed text on compositionend
    imeInput?.addEventListener('compositionend', (e) => {
      const txt = e.data || '';
      if (txt) pulseWithMods(() => sendText(txt));
      // Clear sink
      imeInput.value = '';
    });

    // Kick off
    setStatus('Connecting…');
    loadOS();
  });
  </script>
</body>
</html>
